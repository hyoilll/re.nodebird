{"ast":null,"code":"import { createWrapper } from \"next-redux-wrapper\";\nimport { applyMiddleware, compose, createStore } from \"redux\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\nimport reducer from \"../reducers\";\n\nconst configureStore = () => {\n  // redux-thunk는 redux의 미들웨어\n  // 미들웨어 - redux의 기능을 향상시켜줌\n  // redux-thunk - redux가 비동기 액션을 dispatch할 때 도와줌\n  const middlewares = []; // DevTools가 있어야 브라우저의 Redux관리 탭에 연결되어 확인할 수 있음\n  // 밑에와 같이 개발모드일때만 DevTools를 연결하는 이유는 개발할 때 History를 참고하기 위함이다, 그렇기에 연결해주고,\n  // 베포용일때는 연결안해주는 이유가 남겨지는 History로 인해 보안에 위협이 될 수 있기 때문\n\n  const enhancer = false ? compose(applyMiddleware(...middlewares)) : composeWithDevTools(applyMiddleware(...middlewares));\n  const store = createStore(reducer, enhancer);\n  return store;\n};\n\nconst wrapper = createWrapper(configureStore, {\n  debug: true\n});\nexport default wrapper; // < 리덕스의 원리와 불변성 >\n// store : state + reducer\n// 중앙저장소(이름:효일, 나이:29)의 데이터를 변경하기 위해서는 action이 필요함.\n// action을 dispatch하면 중앙저장소의 데이터가 바뀜\n// a컴포넌트에서 중앙저장소의 이름을 유키로 변경하면 a컴포넌트를 포함하여 중앙저장소의 데이터를 참조하고 있는 모든 컴포넌트에서 이름값이 바뀜\n// but action의 type:change_name을 자바스크립트가 그냥 알 수는 없기 때문에, reducer를 활용하여 action.type이 change_name일 경우에 어떻게 변경되는지 제시해줌\n// 단점 : 데이터를 변경하거나 할 때, action이 점점 늘어남 => reducer도 늘어남\n// 이러한 단점이 있음에도 불구하고 redux를 사용하는게, action을 기준으로 과거 history가 추적이 되기 때문에, 버그잡을 때 매우 편함","map":{"version":3,"sources":["C:/Users/dlgyd/OneDrive/문서/GitHub/re.nodebird/front/store/configureStore.js"],"names":["createWrapper","applyMiddleware","compose","createStore","composeWithDevTools","reducer","configureStore","middlewares","enhancer","store","wrapper","debug"],"mappings":"AAAA,SAASA,aAAT,QAA8B,oBAA9B;AACA,SAASC,eAAT,EAA0BC,OAA1B,EAAmCC,WAAnC,QAAsD,OAAtD;AACA,SAASC,mBAAT,QAAoC,0BAApC;AACA,OAAOC,OAAP,MAAoB,aAApB;;AAEA,MAAMC,cAAc,GAAG,MAAM;AAC3B;AACA;AACA;AACA,QAAMC,WAAW,GAAG,EAApB,CAJ2B,CAK3B;AACA;AACA;;AACA,QAAMC,QAAQ,GACZ,QACIN,OAAO,CAACD,eAAe,CAAC,GAAGM,WAAJ,CAAhB,CADX,GAEIH,mBAAmB,CAACH,eAAe,CAAC,GAAGM,WAAJ,CAAhB,CAHzB;AAIA,QAAME,KAAK,GAAGN,WAAW,CAACE,OAAD,EAAUG,QAAV,CAAzB;AACA,SAAOC,KAAP;AACD,CAdD;;AAgBA,MAAMC,OAAO,GAAGV,aAAa,CAACM,cAAD,EAAiB;AAC5CK,EAAAA,KAAK;AADuC,CAAjB,CAA7B;AAIA,eAAeD,OAAf,C,CAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA","sourcesContent":["import { createWrapper } from \"next-redux-wrapper\";\r\nimport { applyMiddleware, compose, createStore } from \"redux\";\r\nimport { composeWithDevTools } from \"redux-devtools-extension\";\r\nimport reducer from \"../reducers\";\r\n\r\nconst configureStore = () => {\r\n  // redux-thunk는 redux의 미들웨어\r\n  // 미들웨어 - redux의 기능을 향상시켜줌\r\n  // redux-thunk - redux가 비동기 액션을 dispatch할 때 도와줌\r\n  const middlewares = [];\r\n  // DevTools가 있어야 브라우저의 Redux관리 탭에 연결되어 확인할 수 있음\r\n  // 밑에와 같이 개발모드일때만 DevTools를 연결하는 이유는 개발할 때 History를 참고하기 위함이다, 그렇기에 연결해주고,\r\n  // 베포용일때는 연결안해주는 이유가 남겨지는 History로 인해 보안에 위협이 될 수 있기 때문\r\n  const enhancer =\r\n    process.env.NODE_ENV === \"production\"\r\n      ? compose(applyMiddleware(...middlewares))\r\n      : composeWithDevTools(applyMiddleware(...middlewares));\r\n  const store = createStore(reducer, enhancer);\r\n  return store;\r\n};\r\n\r\nconst wrapper = createWrapper(configureStore, {\r\n  debug: process.env.NODE_ENV === \"development\",\r\n});\r\n\r\nexport default wrapper;\r\n\r\n// < 리덕스의 원리와 불변성 >\r\n// store : state + reducer\r\n// 중앙저장소(이름:효일, 나이:29)의 데이터를 변경하기 위해서는 action이 필요함.\r\n// action을 dispatch하면 중앙저장소의 데이터가 바뀜\r\n// a컴포넌트에서 중앙저장소의 이름을 유키로 변경하면 a컴포넌트를 포함하여 중앙저장소의 데이터를 참조하고 있는 모든 컴포넌트에서 이름값이 바뀜\r\n// but action의 type:change_name을 자바스크립트가 그냥 알 수는 없기 때문에, reducer를 활용하여 action.type이 change_name일 경우에 어떻게 변경되는지 제시해줌\r\n\r\n// 단점 : 데이터를 변경하거나 할 때, action이 점점 늘어남 => reducer도 늘어남\r\n// 이러한 단점이 있음에도 불구하고 redux를 사용하는게, action을 기준으로 과거 history가 추적이 되기 때문에, 버그잡을 때 매우 편함\r\n"]},"metadata":{},"sourceType":"module"}